[{"filePath":"C:\\sinkronizacija\\promina-drnis-app\\backend\\src\\controllers\\systemManager.controller.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":201,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":201,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":393,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15474,15477],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15474,15477],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'_error' is defined but never used.","line":995,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":995,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// controllers/systemManager.controller.ts\nimport { Request, Response } from 'express';\nimport systemManagerService from '../services/systemManager.service.js';\nimport { JWT_SECRET } from '../config/jwt.config.js';\nimport jwt from 'jsonwebtoken';\n// Privremeno bez preciznih tipova dok se ne uvedu završne definicije\n// import { SystemManager, SystemManagerLoginData, CreateSystemManagerDto, UpdateMemberPermissionsDto } from '../shared/types/systemManager.js';\nimport bcrypt from 'bcrypt';\nimport auditService from '../services/audit.service.js';\nimport systemManagerRepository from '../repositories/systemManager.repository.js';\nimport prisma from '../utils/prisma.js';\nimport { PerformerType } from '@prisma/client';\n\n// Temporary type definition until a full solution is implemented\ninterface SystemManagerLoginData {\n    username: string;\n    password: string;\n}\n\n// Tip tijela zahtjeva za kreiranje system managera\ninterface CreateSystemManagerBody {\n    username: string;\n    password: string;\n    email?: string;\n    display_name?: string;\n}\n\n// Tip tijela zahtjeva za ažuriranje ovlasti člana\ninterface UpdateMemberPermissionsBody {\n    memberId: number;\n    permissions: Record<string, boolean>;\n}\n\n// Tip proširenja `req.user` je centraliziran u `backend/src/global.d.ts`.\n\n// Change system manager password\nexport const changePassword = async (req: Request, res: Response) => {\n    if (!req.user) {\n        return res.status(401).json({ message: 'Unauthorized' });\n    }\n    const managerId = req.user.id; // obtained from JWT after authentication\n    const { oldPassword, newPassword } = req.body;\n\n    const manager = await prisma.systemManager.findUnique({ where: { id: managerId } });\n    if (!manager) return res.status(404).json({ message: 'System Manager not found' });\n\n    const isMatch = await bcrypt.compare(oldPassword, manager.password_hash);\n    if (!isMatch) return res.status(400).json({ message: 'Incorrect old password' });\n\n    const newHash = await bcrypt.hash(newPassword, 10);\n    await prisma.systemManager.update({\n        where: { id: managerId },\n        data: { password_hash: newHash },\n    });\n\n    return res.json({ message: 'Password changed successfully' });\n};\n\n// PATCH /system-manager/change-username\nexport const changeUsername = async (req: Request, res: Response) => {\n    if (!req.user) {\n        return res.status(401).json({ message: 'Unauthorized' });\n    }\n    const managerId = req.user.id; // obtained from JWT after authentication\n    const { username } = req.body;\n\n    // Check if username is already taken\n    const existingAdmin = await prisma.systemManager.findUnique({ where: { username } });\n    if (existingAdmin && existingAdmin.id !== managerId) {\n        return res.status(400).json({ message: 'Username already exists' });\n    }\n\n    // Update username\n    await prisma.systemManager.update({\n        where: { id: managerId },\n        data: { username },\n    });\n\n    // Log the change in the audit log\n    await auditService.logAction(\n        'update', // action_type\n        managerId,  // performed_by\n        `System manager changed username to: ${username}`, // action_details\n        req,      // req object\n        'success', // status\n        undefined,\n        PerformerType.SYSTEM_MANAGER\n    );\n\n    return res.json({ message: 'Username changed successfully', username });\n};\n\n/**\n * Function to refresh System Manager token\n */\nexport const refreshToken = async (req: Request, res: Response): Promise<void> => {\n    try {\n        // Get refresh token from cookies\n        const refreshToken = req.cookies.systemManagerRefreshToken;\n        \n        if (!refreshToken) {\n            res.status(401).json({ message: 'Refresh token not found' });\n            return;\n        }\n        \n        // Verify refresh token\n        try {\n            const decoded = jwt.verify(refreshToken, JWT_SECRET) as { id: number; type: string; tokenType: string };\n            \n            // Check if the token is indeed a refresh token for the System Manager\n            if (decoded.type !== 'SystemManager' || decoded.tokenType !== 'refresh') {\n                res.status(403).json({ message: 'Invalid token type' });\n                return;\n            }\n            \n            // Get manager from the database\n            const manager = await systemManagerRepository.findById(decoded.id);\n            \n            if (!manager) {\n                res.status(404).json({ message: 'System Manager not found' });\n                return;\n            }\n            \n            // Generate new access token and refresh token\n            const token = systemManagerService.generateToken(manager);\n            const newRefreshToken = systemManagerService.generateRefreshToken(manager);\n\n            await auditService.logAction(\n                'token_refresh',\n                manager.id,\n                `System manager ${manager.username} has refreshed the token`,\n                req,\n                'success',\n                undefined,\n                PerformerType.SYSTEM_MANAGER\n            );\n            \n            // Update last login time\n            await systemManagerRepository.updateLastLogin(manager.id);\n            \n            // Set new refresh token as an HTTP-only cookie\n            const isProduction = process.env.NODE_ENV === 'production';\n            const protocol = req.headers['x-forwarded-proto'] || req.protocol;\n            // Using let instead of const so we can modify the value\n            let secure = isProduction || protocol === 'https';\n            \n            // Dynamic determination of the sameSite setting\n            // For cross-site requests, it's necessary to set sameSite to 'none' and secure to true\n            // Firefox specifically requires this combination for a cross-site context\n            let sameSite: 'strict' | 'lax' | 'none' | undefined;\n            \n            if (isProduction || secure) {\n                sameSite = 'none';\n                // If we use 'none', secure must be true\n                if (sameSite === 'none') {\n                    secure = true;\n                }\n            } else {\n                sameSite = 'lax'; // For local development\n            }\n            \n            // Delete refreshToken cookie if it exists\n            // to avoid conflict between two token types\n            if (req.cookies.refreshToken) {\n                res.clearCookie('refreshToken', { \n                    path: '/api/auth',\n                    secure: secure,\n                    sameSite: sameSite\n                });\n            }\n            \n            // We also check and delete the old systemManagerRefreshToken if it exists\n            if (req.cookies.systemManagerRefreshToken) {\n                res.clearCookie('systemManagerRefreshToken', { \n                    path: '/api/system-manager',\n                    secure: secure,\n                    sameSite: sameSite\n                });\n            }\n            \n            res.cookie('systemManagerRefreshToken', newRefreshToken, {\n                httpOnly: true,\n                secure: secure,\n                sameSite: sameSite,\n                maxAge: 7 * 24 * 60 * 60 * 1000, // 7 days\n                path: '/api/system-manager' // Restricted to the /api/system-manager path\n            });\n            \n            // Return new token\n            res.json({\n                token,\n                manager: {\n                    id: manager.id,\n                    username: manager.username,\n                    email: manager.email,\n                    display_name: manager.display_name,\n                    role: 'SystemManager',\n                    last_login: manager.last_login\n                }\n            });\n        } catch (_error) {\n            // If the token has expired or is invalid\n            res.status(403).json({ message: 'Invalid or expired refresh token' });\n        }\n    } catch (error) {\n        console.error('Error refreshing token:', error);\n        res.status(500).json({ message: 'Internal server error' });\n    }\n};\n\nconst systemManagerController = {\n    // System manager login\n    async login(\n        req: Request<Record<string, never>, Record<string, never>, SystemManagerLoginData>,\n        res: Response\n    ): Promise<void> {\n        try {\n            const { username, password } = req.body;\n\n            // Input data validation\n            if (!username || !password) {\n                res.status(400).json({ message: 'Username and password are required' });\n                return;\n            }\n\n            // User authentication\n            const manager = await systemManagerService.authenticate(username, password);\n            \n            if (!manager) {\n                res.status(401).json({ message: 'Invalid username or password' });\n                return;\n            }\n\n            // Generate JWT token and refresh token\n            const token = jwt.sign({ id: manager.id, role: 'SystemManager', type: 'SystemManager', tokenType: 'access' }, JWT_SECRET, { expiresIn: '15m' });\n            const refreshToken = jwt.sign({ id: manager.id, role: 'SystemManager', type: 'SystemManager', tokenType: 'refresh' }, JWT_SECRET, { expiresIn: '7d' });\n\n            await auditService.logAction(\n                'login', // action_type\n                manager.id, // performed_by\n                `System manager ${username} has logged into the system`, // action_details\n                req,      // req object\n                'success', // status\n                undefined, // affected_member\n                PerformerType.SYSTEM_MANAGER\n            );\n\n            // Set new refresh token as an HTTP-only cookie\n            const isProduction = process.env.NODE_ENV === 'production';\n            const protocol = req.headers['x-forwarded-proto'] || req.protocol;\n            // Using let instead of const so we can modify the value\n            let secure = isProduction || protocol === 'https';\n            \n            // Dynamic determination of the sameSite setting\n            // For cross-site requests, it's necessary to set sameSite to 'none' and secure to true\n            // Firefox specifically requires this combination for a cross-site context\n            let sameSite: 'strict' | 'lax' | 'none' | undefined;\n            \n            if (isProduction || secure) {\n                sameSite = 'none';\n                // Ako koristimo 'none', secure mora biti true\n                if (sameSite === 'none') {\n                    secure = true;\n                }\n            } else {\n                sameSite = 'lax'; // Za lokalni razvoj\n            }\n            \n            // Brisanje refreshToken kolačića ako postoji\n            // kako bi se izbjegao konflikt između dva tipa tokena\n            if (req.cookies.refreshToken) {\n                res.clearCookie('refreshToken', { \n                    path: '/api/auth',\n                    secure: secure,\n                    sameSite: sameSite\n                });\n            }\n            \n            // Također provjeravamo i brišemo stari systemManagerRefreshToken ako postoji\n            if (req.cookies.systemManagerRefreshToken) {\n                res.clearCookie('systemManagerRefreshToken', { \n                    path: '/api/system-manager',\n                    secure: secure,\n                    sameSite: sameSite\n                });\n            }\n            \n            res.cookie('systemManagerRefreshToken', refreshToken, {\n                httpOnly: true,\n                secure: secure,\n                sameSite: sameSite,\n                maxAge: 7 * 24 * 60 * 60 * 1000, // 7 dana\n                path: '/api/system-manager' // Ograničeno na /api/system-manager putanju\n            });\n\n            // Vrati token i osnovne podatke o manageru\n            res.json({\n                token,\n                manager: {\n                    id: manager.id,\n                    username: manager.username,\n                    email: manager.email,\n                    display_name: manager.display_name,\n                    role: 'SystemManager',\n                    last_login: manager.last_login\n                }\n            });\n        } catch (error) {\n            console.error('Error during system manager login:', error);\n            res.status(500).json({ message: 'Error occurred during login' });\n        }\n    },\n\n    // Kreiranje novog system managera (može napraviti samo postojeći system manager)\n    async createSystemManager(\n        req: Request<Record<string, never>, Record<string, never>, CreateSystemManagerBody>,\n        res: Response\n    ): Promise<void> {\n        try {\n            const { username, password, email, display_name } = req.body;\n\n            // Validacija ulaznih podataka\n            if (!username || !password) {\n                res.status(400).json({ message: 'Potrebno je unijeti korisničko ime i lozinku' });\n                return;\n            }\n\n            // Provjera postoji li već korisnik s tim korisničkim imenom\n            const existingAdmin = await systemManagerRepository.findByUsername(username);\n            if (existingAdmin) {\n                res.status(400).json({ message: 'Username already exists' });\n                return;\n            }\n\n            // Kreiranje novog system managera\n            const newAdmin = await systemManagerService.createSystemManager({\n                username,\n                password,\n                ...(email !== undefined ? { email } : {}),\n                ...(display_name !== undefined ? { display_name } : {})\n            });\n\n            // Zabilježi kreiranje u audit log\n            if (req.user) {\n                await auditService.logAction(\n                    'create', // action_type\n                    req.user.id, // performed_by\n                    `Created new system manager: ${username}`, // action_details\n                    req, // req objekt\n                    'success', // status\n                    undefined,\n                    req.user.performer_type\n                );\n            }\n\n            // Vrati osnovne podatke o novom korisniku (bez lozinke)\n            res.status(201).json({\n                id: newAdmin.id,\n                username: newAdmin.username,\n                email: newAdmin.email,\n                display_name: newAdmin.display_name,\n                created_at: newAdmin.created_at\n            });\n        } catch (error) {\n            console.error('Error creating system manager:', error);\n            res.status(500).json({ message: 'Error occurred while creating system manager' });\n        }\n    },\n\n    // Provjera postoji li već system manager u sustavu\n    async checkSystemManagerExists(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            const exists = await systemManagerService.systemManagerExists();\n            res.json({ exists });\n        } catch (error) {\n            console.error('Error checking if system manager exists:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom provjere postojanja system managera' });\n        }\n    },\n\n    // Dohvat svih system managera\n    async getAllSystemManagers(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            const managers = await systemManagerService.getAllSystemManagers();\n            \n            // Vrati listu system managera bez osjetljivih podataka\n            res.json(managers.map((manager: any) => ({\n                id: manager.id,\n                username: manager.username,\n                email: manager.email,\n                display_name: manager.display_name,\n                last_login: manager.last_login,\n                created_at: manager.created_at\n            })));\n        } catch (error) {\n            console.error('Error fetching system managers:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata system managera' });\n        }\n    },\n\n    // Dohvat ovlasti za konkretnog člana\n    async getMemberPermissions(\n        req: Request<{ memberId: string }>,\n        res: Response\n    ): Promise<void> {\n        try {\n            const memberId = parseInt(req.params.memberId);\n            \n            if (isNaN(memberId)) {\n                res.status(400).json({ message: 'Neispravan ID člana' });\n                return;\n            }\n            \n            const permissions = await systemManagerService.getMemberPermissions(memberId);\n            \n            if (!permissions) {\n                res.status(404).json({ message: 'Član nije pronađen ili nema dodijeljene ovlasti' });\n                return;\n            }\n            \n            res.json(permissions);\n        } catch (error) {\n            console.error('Error fetching member permissions:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata ovlasti člana' });\n        }\n    },\n\n    // Ažuriranje ovlasti za člana\n    async updateMemberPermissions(\n        req: Request<Record<string, never>, Record<string, never>, UpdateMemberPermissionsBody>,\n        res: Response\n    ): Promise<void> {\n        try {\n            const { memberId, permissions } = req.body;\n            \n            if (!memberId || !permissions) {\n                res.status(400).json({ message: 'Potrebno je unijeti ID člana i ovlasti' });\n                return;\n            }\n            \n            // Provjera postoji li član\n            const member = await prisma.member.findUnique({\n                where: { member_id: memberId }\n            });\n            \n            if (!member) {\n                res.status(404).json({ message: 'Član nije pronađen' });\n                return;\n            }\n            \n            // Ažuriranje ovlasti\n            await systemManagerService.updateMemberPermissions(\n                memberId,\n                permissions,\n                req.user?.id || 0\n            );\n            \n            // Zabilježi promjenu u audit log\n            if (req.user) {\n                const permissionsArray = Object.entries(permissions)\n                    .filter(([_, value]) => value === true)\n                    .map(([key, _]) => key);\n                \n                await auditService.logAction(\n                    'update', // action_type\n                    req.user.id, // performed_by\n                    `Ažurirane ovlasti za člana (ID: ${memberId}): ${permissionsArray.join(', ')}`, // action_details\n                    req, // req objekt\n                    'success', // status\n                    memberId // affected_member\n                );\n            }\n            \n            res.json({ \n                message: 'Ovlasti uspješno ažurirane',\n                memberId,\n                permissions\n            });\n        } catch (error) {\n            console.error('Error updating member permissions:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom ažuriranja ovlasti člana' });\n        }\n    },\n\n    // Dohvat svih članova s manager ovlastima\n    async getMembersWithPermissions(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            const members = await systemManagerService.getMembersWithPermissions();\n            res.json(members);\n        } catch (error) {\n            console.error('Error fetching members with permissions:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata članova s ovlastima' });\n        }\n    },\n\n    // Dohvat svih članova koji nemaju administratorske ovlasti\n    async getMembersWithoutPermissions(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            const members = await systemManagerService.getMembersWithoutPermissions();\n            res.json(members);\n        } catch (error) {\n            console.error('Error fetching members without permissions:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata članova bez ovlasti' });\n        }\n    },\n\n    // Uklanjanje svih ovlasti za člana\n    async removeMemberPermissions(\n        req: Request<{ memberId: string }>,\n        res: Response\n    ): Promise<void> {\n        try {\n            const memberId = parseInt(req.params.memberId);\n            \n            if (isNaN(memberId)) {\n                res.status(400).json({ message: 'Neispravan ID člana' });\n                return;\n            }\n            \n            // Provjera postoji li član\n            const member = await prisma.member.findUnique({\n                where: { member_id: memberId }\n            });\n            \n            if (!member) {\n                res.status(404).json({ message: 'Član nije pronađen' });\n                return;\n            }\n            \n            // Provjera ima li član ovlasti\n            const permissions = await prisma.memberPermissions.findUnique({\n                where: { member_id: memberId }\n            });\n            \n            if (!permissions) {\n                res.status(404).json({ message: 'Član nema dodijeljene ovlasti' });\n                return;\n            }\n            \n            // Uklanjanje ovlasti\n            await systemManagerService.removeMemberPermissions(memberId);\n            \n            // Zabilježi promjenu u audit log\n            if (req.user) {\n                await auditService.logAction(\n                    'delete', // action_type\n                    req.user.id, // performed_by\n                    `Uklonjene sve ovlasti za člana (ID: ${memberId})`, // action_details\n                    req, // req objekt\n                    'success', // status\n                    memberId // affected_member\n                );\n            }\n            \n            res.json({ \n                message: 'Ovlasti uspješno uklonjene',\n                memberId\n            });\n        } catch (error) {\n            console.error('Error removing member permissions:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom uklanjanja ovlasti člana' });\n        }\n    },\n\n    // Dohvat statistika za system manager dashboard\n    async getDashboardStats(\n        req: Request,\n        res: Response\n    ): Promise<void> { \n        try {\n            const totalMembers = await prisma.member.count();\n            const registeredMembers = await prisma.member.count({ where: { status: 'registered' } });\n            const activeMembers = await prisma.member.count({ where: { status: 'active' } }); \n            const pendingApprovals = await prisma.member.count({ where: { registration_completed: false } });\n\n            // TODO: Implementirati dohvat ostalih statistika\n            const stats = {\n                totalMembers,\n                registeredMembers,\n                activeMembers,\n                pendingApprovals,\n                recentActivities: 0, // Placeholder\n                systemHealth: 'Healthy', // Placeholder\n                lastBackup: 'Never', // Placeholder\n            };\n\n            res.json(stats);\n            return;\n        } catch (error) {\n            console.error('Error fetching dashboard stats:', error);\n            res.status(500).json({ message: 'Error fetching dashboard stats' });\n            return;\n        }\n    },\n\n    // Dohvat sistemskih postavki\n    async getSystemSettings(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            const settings = await systemManagerService.getSystemSettings();\n            res.json(settings);\n        } catch (error) {\n            console.error('Error fetching system settings:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata sistemskih postavki' });\n        }\n    },\n\n    // Ažuriranje sistemskih postavki\n    async updateSystemSettings(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            console.log('--- USER OBJECT IN updateSystemSettings ---', req.user);\n\n            if (!req.user) {\n                res.status(401).json({ message: 'Unauthorized' });\n                return;\n            }\n\n            const { id, cardNumberLength, renewalStartMonth, renewalStartDay, timeZone } = req.body;\n            \n            // Validacija ulaznih podataka\n            if (!id) {\n                res.status(400).json({ message: 'Potrebno je unijeti ID postavki' });\n                return;\n            }\n            \n            // Dodatne validacije\n            if (cardNumberLength !== null && cardNumberLength !== undefined) {\n                const cardNumLength = parseInt(cardNumberLength);\n                if (isNaN(cardNumLength) || cardNumLength < 1 || cardNumLength > 10) {\n                    res.status(400).json({ message: 'Duljina broja članske iskaznice mora biti između 1 i 10' });\n                    return;\n                }\n            }\n            \n            if (renewalStartMonth !== null && renewalStartMonth !== undefined) {\n                const month = parseInt(renewalStartMonth);\n                if (isNaN(month) || month < 1 || month > 12) {\n                    res.status(400).json({ message: 'Mjesec obnove članarine mora biti između 1 i 12' });\n                    return;\n                }\n            }\n            \n            if (renewalStartDay !== null && renewalStartDay !== undefined) {\n                const day = parseInt(renewalStartDay);\n                if (isNaN(day) || day < 1 || day > 31) {\n                    res.status(400).json({ message: 'Dan obnove članarine mora biti između 1 i 31' });\n                    return;\n                }\n            }\n            \n            // Validacija vremenske zone\n            if (timeZone && !isValidTimeZone(timeZone)) {\n                res.status(400).json({ message: 'Neispravna vremenska zona' });\n                return;\n            }\n            \n            // Ažuriranje postavki\n            const updatedSettings = await systemManagerService.updateSystemSettings({\n                id,\n                cardNumberLength: cardNumberLength !== undefined ? parseInt(cardNumberLength) : undefined,\n                renewalStartMonth: renewalStartMonth !== undefined ? parseInt(renewalStartMonth) : undefined,\n                renewalStartDay: renewalStartDay !== undefined ? parseInt(renewalStartDay) : undefined,\n                timeZone\n            }, req.user.id);\n            \n            // Zabilježi promjenu u audit log\n            if (req.user) {\n                const changedSettings = [];\n                if (cardNumberLength !== undefined) changedSettings.push(`cardNumberLength: ${cardNumberLength}`);\n                if (renewalStartMonth !== undefined) changedSettings.push(`renewalStartMonth: ${renewalStartMonth}`);\n                if (renewalStartDay !== undefined) changedSettings.push(`renewalStartDay: ${renewalStartDay}`);\n                if (timeZone) changedSettings.push(`timeZone: ${timeZone}`);\n                \n                await auditService.logAction(\n                    'update', // action_type\n                    req.user.id, // performed_by\n                    `Updated system settings: ${changedSettings.join(', ')}`, // action_details\n                    req, // req objekt\n                    'success' // status\n                );\n            }\n            \n            res.json({\n                message: 'Settings updated successfully',\n                settings: updatedSettings\n            });\n        } catch (error) {\n            console.error('Error updating system settings:', error);\n            res.status(500).json({ message: 'Error occurred while updating system settings' });\n        }\n    },\n\n    // Dohvat svih revizijskih zapisa (audit logs)\n    async getAuditLogs(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            const logs = await auditService.getAllLogs();\n            res.json(logs);\n        } catch (error) {\n            console.error('Error fetching audit logs:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata revizijskih zapisa' });\n        }\n    },\n\n    // Dohvat svih članova sa statusom 'pending'\n    async getPendingMembers(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            const pendingMembers = await prisma.member.findMany({\n                where: {\n                    registration_completed: false\n                },\n                select: {\n                    member_id: true,\n                    first_name: true,\n                    last_name: true,\n                    email: true,\n                    cell_phone: true,\n                    created_at: true,\n                    membership_details: {\n                        select: {\n                            status: true\n                        }\n                    }\n                },\n                orderBy: {\n                    created_at: 'desc'\n                }\n            });\n            \n            res.json(pendingMembers);\n        } catch (error) {\n            console.error('Error fetching pending members:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata članova na čekanju' });\n        }\n    },\n\n    // Dodjeljivanje lozinke članu (aktivacija korisničkog računa)\n    async assignPasswordToMember(\n        req: Request<\n            Record<string, never>,\n            Record<string, never>,\n            { memberId: number; password: string; cardNumber?: string }\n        >,\n        res: Response\n    ): Promise<void> {\n        try {\n            const { memberId, password, cardNumber } = req.body;\n            \n            if (!memberId || !password) {\n                res.status(400).json({ message: 'Member ID and password are required' });\n                return;\n            }\n            \n            // Provjera postoji li član\n            const member = await prisma.member.findUnique({\n                where: { member_id: memberId }\n            });\n            \n            if (!member) {\n                res.status(404).json({ message: 'Član nije pronađen' });\n                return;\n            }\n            \n            // Provjera je li član već aktiviran\n            if (member.status !== 'pending') {\n                res.status(400).json({ message: 'Member is already activated' });\n                return;\n            }\n            \n            // Hashiranje lozinke\n            const saltRounds = 10;\n            const hashedPassword = await bcrypt.hash(password, saltRounds);\n            \n            // Ažuriranje člana\n            await prisma.member.update({\n                where: { member_id: memberId },\n                data: {\n                    password_hash: hashedPassword,\n                    status: 'registered',\n                }\n            });\n            \n            // Ažuriranje broja kartice u membership_details ako je potrebno\n            if (cardNumber) {\n                await prisma.membershipDetails.update({\n                    where: { member_id: memberId },\n                    data: {\n                        card_number: cardNumber\n                    }\n                });\n                \n                // Provjeri postoji li već CardNumber zapis s ovim brojem kartice\n                const existingCardNumber = await prisma.cardNumber.findUnique({\n                    where: { card_number: cardNumber }\n                });\n                \n                if (existingCardNumber) {\n                    // Ažuriraj postojeći zapis\n                    await prisma.cardNumber.update({\n                        where: { id: existingCardNumber.id },\n                        data: {\n                            member_id: memberId,\n                            status: 'assigned',\n                            assigned_at: new Date()\n                        }\n                    });\n                } else {\n                    // Kreiraj novi zapis\n                    await prisma.cardNumber.create({\n                        data: {\n                            card_number: cardNumber,\n                            status: 'assigned',\n                            member_id: memberId,\n                            assigned_at: new Date()\n                        }\n                    });\n                }\n            }\n            \n            // Zabilježi promjenu u audit log\n            if (req.user) {\n                await auditService.logAction(\n                    'update', // action_type\n                    req.user.id, // performed_by\n                    `Aktiviran korisnički račun za člana (ID: ${memberId})`, // action_details\n                    req, // req objekt\n                    'success', // status\n                    memberId // affected_member\n                );\n            }\n            \n            res.json({ \n                message: 'Korisnički račun uspješno aktiviran',\n                memberId,\n                status: 'registered'\n            });\n        } catch (error) {\n            console.error('Error assigning password to member:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom aktivacije korisničkog računa' });\n        }\n    },\n\n    // Dohvat profila trenutnog system managera\n    async getCurrentSystemManager(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            if (!req.user || !req.user.is_SystemManager) {\n                res.status(401).json({ message: 'Unauthorized' });\n                return;\n            }\n\n            const manager = await prisma.systemManager.findUnique({\n                where: { id: req.user.id },\n                select: {\n                    id: true,\n                    username: true,\n                    email: true,\n                    display_name: true,\n                    last_login: true,\n                    created_at: true,\n                    updated_at: true\n                }\n            });\n\n            if (!manager) {\n                res.status(404).json({ message: 'System manager not found' });\n                return;\n            }\n\n            res.json(manager);\n        } catch (error) {\n            console.error('Error fetching current system manager:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata profila system managera' });\n        }\n    },\n\n    // Dohvat informacija o zdravlju sustava\n    async getSystemHealth(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            // Implementacija dohvata informacija o zdravlju sustava\n            res.json({ message: 'Not implemented yet' });\n        } catch (error) {\n            console.error('Error fetching system health:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dohvata informacija o zdravlju sustava' });\n        }\n    },\n\n    // Kreiranje sigurnosne kopije sustava\n    async createSystemBackup(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            // Implementacija kreiranja sigurnosne kopije\n            res.json({ message: 'Not implemented yet' });\n        } catch (error) {\n            console.error('Error creating system backup:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom kreiranja sigurnosne kopije' });\n        }\n    },\n\n    // Vraćanje sustava iz sigurnosne kopije\n    async restoreSystemBackup(\n        req: Request,\n        res: Response\n    ): Promise<void> {\n        try {\n            // Implementacija vraćanja iz sigurnosne kopije\n            res.status(501).json({ message: 'Not implemented yet' });\n        } catch (error) {\n            console.error('Error restoring system from backup:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom vraćanja sustava iz sigurnosne kopije' });\n        }\n    },\n\n    // Dodjeljivanje uloge članu (member_superuser)\n    async assignRoleToMember(\n        req: Request<Record<string, never>, Record<string, never>, { memberId: number; role: 'member' | 'member_administrator' | 'member_superuser' }>,\n        res: Response\n    ): Promise<void> {\n        try {\n            if (!req.user) {\n                res.status(401).json({ message: 'Unauthorized' });\n                return;\n            }\n\n            const { memberId, role } = req.body;\n            \n            // Provjera postoji li član\n            const member = await prisma.member.findUnique({\n                where: { member_id: memberId }\n            });\n            \n            if (!member) {\n                res.status(404).json({ message: 'Član nije pronađen' });\n                return;\n            }\n            \n            // Ažuriranje uloge člana\n            await prisma.member.update({\n                where: { member_id: memberId },\n                data: { role }\n            });\n            \n            // Zabilježi promjenu u audit log\n            await auditService.logAction(\n                'update',\n                req.user.id,\n                `System manager dodijelio ulogu ${role} članu ID: ${memberId}`,\n                req,\n                'success',\n                memberId\n            );\n            \n            res.status(200).json({ message: `Uloga ${role} uspješno dodijeljena članu` });\n        } catch (error) {\n            console.error('Error assigning role to member:', error);\n            res.status(500).json({ message: 'Došlo je do greške prilikom dodjeljivanja uloge članu' });\n        }\n    }\n};\n\n// Pomoćna funkcija za validaciju vremenske zone\nfunction isValidTimeZone(timeZone: string): boolean {\n    try {\n        Intl.DateTimeFormat(undefined, { timeZone });\n        return true;\n    } catch (_error) {\n        return false;\n    }\n}\n\n// Funkcija za odjavu system managera i poništavanje refresh tokena\nasync function logoutHandler(req: Request, res: Response): Promise<void> {\n    const refreshToken = req.cookies.systemManagerRefreshToken;\n    \n    // Određivanje postavki za kolačiće\n    const isProduction = process.env.NODE_ENV === 'production';\n    const isSecure = req.secure || req.headers['x-forwarded-proto'] === 'https';\n    \n    let secure = isSecure || isProduction;\n    let sameSite: 'strict' | 'lax' | 'none' | undefined;\n    \n    if (isProduction || secure) {\n        sameSite = 'none';\n        if (sameSite === 'none') {\n            secure = true;\n        }\n    } else {\n        sameSite = 'lax';\n    }\n    \n    // Ako nema refresh tokena, samo obriši kolačiće i vrati uspjeh\n    if (!refreshToken) {\n        // Briši oba tipa kolačića za svaki slučaj\n        res.clearCookie('systemManagerRefreshToken', { \n            path: '/api/system-manager',\n            secure: secure,\n            sameSite: sameSite\n        });\n        res.clearCookie('refreshToken', { \n            path: '/api/auth',\n            secure: secure,\n            sameSite: sameSite\n        });\n        res.status(200).json({ message: 'Uspješna odjava system managera' });\n        return;\n    }\n    \n    try {\n        // Provjeri postoji li token u bazi i obriši ga\n        await prisma.refresh_tokens.deleteMany({\n            where: { token: refreshToken }\n        });\n        \n        // Obriši oba tipa kolačića s ispravnim postavkama\n        res.clearCookie('systemManagerRefreshToken', { \n            path: '/api/system-manager',\n            secure: secure,\n            sameSite: sameSite\n        });\n        res.clearCookie('refreshToken', { \n            path: '/api/auth',\n            secure: secure,\n            sameSite: sameSite\n        });\n        \n        res.status(200).json({ message: 'Uspješna odjava system managera' });\n    } catch (error) {\n        console.error('Greška pri odjavi system managera:', error);\n        res.status(500).json({ error: 'Došlo je do greške pri odjavi' });\n    }\n}\n\nexport { logoutHandler };\n\nexport default systemManagerController;\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":["@stylistic/js/no-extra-semi"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"10.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin-js","url":"https://eslint.style/packages/js"},"rule":{"name":"no-extra-semi","url":"https://eslint.style/rules/js/no-extra-semi"}}]}},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":["@stylistic/js/no-mixed-spaces-and-tabs"],"info":{"message":"Formatting rules are being moved out of ESLint core.","url":"https://eslint.org/blog/2023/10/deprecating-formatting-rules/","deprecatedSince":"8.53.0","availableUntil":"10.0.0","replacedBy":[{"message":"ESLint Stylistic now maintains deprecated stylistic core rules.","url":"https://eslint.style/guide/migration","plugin":{"name":"@stylistic/eslint-plugin-js","url":"https://eslint.style/packages/js"},"rule":{"name":"no-mixed-spaces-and-tabs","url":"https://eslint.style/rules/js/no-mixed-spaces-and-tabs"}}]}}]}]